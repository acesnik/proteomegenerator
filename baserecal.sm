# Base Recalibration


# dict created by mutect2

rule CreateSequenceGroupings:
    input: config['dict']
    output: path="out/sequence_groups.txt"
    params: n="1", R="'span[hosts=1] rusage[mem=10]'", \
            o="out/logs/create_sequence_groups.out", eo="out/logs/create_sequence_groups.err", \
            J="create_seq_groups"
    run:    with open(config['dict'],'r') as ref_dict_file:
                sequence_tuple_list = []
                longest_sequence = 0
                for line in ref_dict_file:
                        if line.startswith("@SQ"):
                                line_split = line.split("\t")
                                # (Sequence_name, Sequence_length)
                                sequence_tuple_list.append((line_split[1].split("SN:")[1], int(line_split[2].split("LN:")[1])))
                longest_sequence = sorted(sequence_tuple_list, key=lambda x: x[1], reverse=True)[0][1]
            # initialize the txt string with the first sequence
            txt_string = sequence_tuple_list[0][0]
            temp_size = sequence_tuple_list[0][1]
            for sequence_tuple in sequence_tuple_list[1:]:
                if temp_size + sequence_tuple[1] <= longest_sequence:
                        temp_size += sequence_tuple[1]
                        txt_string += "," + str(sequence_tuple[0])
                else:
                        txt_string += " " + str(sequence_tuple[0])
                        temp_size = sequence_tuple[1]
            f = open(output.path,'w')
            f.write(txt_string)
            f.close()

# Last line may cause errors?

rule BaseRecalibrator:
    input: bam=temp("out/{sample_alignment}.readyforBQSR.bam"),groups_file="out/sequence_groups.txt"
    output: "out/recal/{sample_alignment}.{group}.report"
    params: n="8", R="'span[hosts=1] rusage[mem=4]'", \
	        o="out/logs/recal/{group}_recal.out", eo="out/logs/recal/{group}_recal.err", \
	        J="base_recal_{group}"
    wildcard_constraints: group="\d+"
    shell: "{JAVA} -Dsamjdk.use_async_io=false \
            -Djava.io.tmpdir={TMP} -Xmx30g -jar {GATK37JAR} -T BaseRecalibrator \
            -nct {params.n} -R {config[ref]} -I {input.bam} \
	        --useOriginalQualities -o {output} \
            -knownSites {config[snp]} -knownSites {config[indel]} \
	        --interval_padding 100 \
	        -L $(sed -n {wildcards.group}p {input.groups_file} | sed -r 's/\t/ -L /g')"

rule GatherBqsrReports:
    input: expand("out/recal/{{sample_alignment}}.{group}.report", group=NUM_TARGETS_RANGE)
    output: "out/recal/{sample_alignment}.BQSR_full.report"
    params: n="8", R="'span[hosts=1] rusage[mem=10]'", \
	        o="out/logs/gather_reports.out", eo="out/logs/gather_reports.err", \
	        J="gather_reports"
    shell: "{JAVA} -Xmx32g -cp {GATK37JAR} org.broadinstitute.gatk.tools.GatherBqsrReports \
	       $(echo {input} | sed -r 's/[^ ]+/INPUT=&/g') \
	       OUTPUT={output}"

# last line may cause errors?

rule ApplyBQSRToMappedReads:
    input: bqsr="out/recal/{sample_alignment}.BQSR_full.report",bam=temp("out/{sample_alignment}.readyforBQSR.bam"), \
	       groups_file="out/sequence_groups.txt"
    output: temp("out/recal/{sample_alignment}.{group}_recal.bam")
    wildcard_constraints: group="\d+"
    params: n="8", R="'span[hosts=1] rusage[mem=4]'", \
	        o="out/logs/mapped_bqsr_{group}.out", eo="out/logs/mapped_bqsr{group}.err", \
	        J="mapped_bqsr"
    shell: "{JAVA} -XX:+PrintFlagsFinal -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps \
	      -XX:+PrintGCDetails -Xloggc:gc_log.log -Dsamjdk.use_async_io=false \
	      -XX:GCTimeLimit=50 -XX:GCHeapFreeLimit=10 -Xmx30g \
	      -jar {GATK37JAR} -T PrintReads -nct {params.n} --generate_md5 --keep_program_records \
	      -R {config[ref]} -I {input.bam} --useOriginalQualities -o {output} \
	      --BQSR {input.bqsr} -SQQ 10 -SQQ 20 -SQQ 30 -SQQ 40 --emit_original_quals \
	      -L $(sed -n {wildcards.group}p {input.groups_file} | sed -r 's/\t/ -L /g')"

rule ApplyBQSRToUnmappedReads:
    input: bqsr="out/recal/{sample_alignment}.BQSR_full.report",bam=temp("out/{sample_alignment}.readyforBQSR.bam"), \
	       groups_file=config['targets']
    output: temp("out/recal/{sample_alignment}.unmapped_recal.bam")
    params: n="8", R="'span[hosts=1] rusage[mem=4]'", \
	        o="out/logs/unmapped_bqsr.out", eo="out/logs/unmapped_bqsr.err", \
	        J="unmapped_bqsr"
    shell: "{JAVA} -XX:+PrintFlagsFinal -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps \
	      -XX:+PrintGCDetails -Xloggc:gc_log.log -Dsamjdk.use_async_io=false \
	      -XX:GCTimeLimit=50 -XX:GCHeapFreeLimit=10 -Xmx32g \
	      -jar {GATK37JAR} -T PrintReads -nct {params.n} --generate_md5 --keep_program_records \
	      -R {config[ref]} -I {input.bam} --useOriginalQualities -o {output} \
	      --BQSR {input.bqsr} -SQQ 10 -SQQ 20 -SQQ 30 -SQQ 40 --emit_original_quals \
	      -L unmapped"

rule GatherRecalibratedBAMs:
    input: mapped=expand(temp("out/recal/{{sample_alignment}}.{group}_recal.bam"),group=NUM_TARGETS_RANGE), \
	       unmapped=temp("out/recal/{sample_alignment}.unmapped_recal.bam")
    output: "out/{sample_alignment}.recal.bam"
    params: n="4", R="'span[hosts=1] rusage[mem=9]'", \
	        o="out/logs/gather_recal.out", eo="out/logs/gather_recal.err", \
	        J="gather_recal"
    shell: "{PICARD} GatherBamFiles -Xmx32g \
            $(echo '{input.mapped}' | sed -r \'s/[^ ]+/INPUT=&/g') \
	        INPUT={input.unmapped} OUTPUT={output} \
            CREATE_INDEX=true CREATE_MD5_FILE=true"
