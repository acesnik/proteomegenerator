rule filter:
    input: bam="out/{sample}.Aligned.sortedByCoord.out.bam"
    output: "out/{sample}.Aligned.trimmed.out.bam"
    log: "out/logs/{sample}.filter.txt"
    benchmark: "out/benchmarks/{sample}.filter.txt"
    params: n="1", R="'span[hosts=1] rusage[mem=10]'", J="filter", o="out/logs/filter.out", eo="out/logs/filter.err"
    shell: "grep protein_coding {GTF} > out/protein_coding.gtf ; \
        grep pseudogene {GTF} > out/pseudogene.gtf ; \
        {SAMTOOLS} view -b -h -F 4 -F 8 -F 256 -F 512 -F 2048 -q 30 {input.bam} > {output} 2> {log}"


rule BuildBamIndex:
    input: "out/{sample}.Aligned.trimmed.out.bam"
    output: "out/{sample}.Aligned.trimmed.out.bai"
    benchmark: "out/benchmarks/{sample}.BuildBamIndex.txt"
    log: "out/logs/{sample}.BuildBamIndex.txt"
    params: n="1", R="'span[hosts=1] rusage[mem=10]'", J="BuildBamIndex", o="out/logs/BuildBamIndex.out", eo="out/logs/BuildBamIndex.err"
    shell: "java -Djava.io.tmpdir={TMP} -Xmx6g -jar {PICARD} \
            BuildBamIndex \
            INPUT={input} 2> {log}"


rule StringTie:
    input: bam="out/{sample}.Aligned.trimmed.out.bam", bai="out/{sample}.Aligned.trimmed.out.bai"
    output: "out/{sample}-stringtie.gtf"
    log: "out/logs/{sample}.filterAndTrimBed.txt"
    benchmark: "out/benchmarks/{sample}.StringTie.txt"
    params: n="6", R="'span[hosts=1] rusage[mem=20]'", J="StringTie", o="out/logs/StringTie.out", eo="out/logs/StringTie.err"
    shell: "{STRINGTIE} \
            -G {GTF} \
            {input.bam} \
            -p {params.n} \
            -o {output} \
            -c 2.5 \
            -m 300 \
            -f .01 2> {log}"


snakemake.utils.makedirs('out/all-merge')


rule merge:
    input: expand("out/{sample}-stringtie.gtf",sample=SAMPLES)
    output: "out/all-merge/merged.gtf"
    log: "out/logs/merge.txt"
    benchmark: "out/benchmarks/merge.txt"
    params: n="12", R="'span[hosts=1] rusage[mem=4]'", J="merge", o="out/logs/merge.out", eo="out/logs/merge.err"
    shell: "{STRINGTIE} \
            --merge \
            -o {output} \
            -p {params.n} \
            -c 2.5 \
            -m 300 \
            -T 1 \
            -f .01 \
            -i \
            {input} 2> {log}"


rule UCSC:
    input: "out/all-merge/merged.gtf"
    output: merged="out/all-merge/merged-UCSC.gtf", reference="out/all-merge/reference-UCSC.gtf"
    benchmark: "out/benchmarks/UCSC.txt"
    log: "out/logs/UCSC.txt"
    params: n="1", R="'span[hosts=1] rusage[mem=10]'", J="UCSC", o="out/logs/UCSC.out", eo="out/logs/UCSC.err"
    shell: "cat {GTF} | grep chr > {output.reference}; \
        cat {input} | grep chr > {output.merged} 2> {log}"


rule gtf_file_to_cDNA_seqs:
    input: "out/all-merge/{model}-UCSC.gtf"
    output: fasta="out/all-merge/{model}.transcripts.fasta",
        gtf="out/all-merge/{model}.transcripts.gtf"
    benchmark: "out/benchmarks/gtf_file_to_cDNA_seqs.txt"
    log: "out/logs/gtf_file_to_cDNA_seqs.txt"
    params: n="1", R="'span[hosts=1] rusage[mem=10]'", J="gtf_file_to_cDNA_seqs", o="out/logs/gtf_file_to_cDNA_seqs.out", eo="out/logs/gtf_file_to_cDNA_seqs.err"
    shell: "{GFFREAD}/gffread {input} -T -o {output.gtf} \
        --no-pseudo \
        --force-exons \
        -M -Q; \
        {GFFREAD}/gffread -w {output.fasta} -g {FASTA} {output.gtf} 2> {log}"


rule LongOrfs:
    input: "out/all-merge/{model}.transcripts.fasta"
    output: "out/all-merge/{model}.transcripts.fasta.transdecoder_dir/longest_orfs.pep"
    benchmark: "out/benchmarks/{model}.LongOrfs.json"
    log: "../logs/LongOrfs.txt"
    params: n="1", R="'span[hosts=1] rusage[mem=10]'", J="LongOrfs", o="out/logs/LongOrfs.out", eo="out/logs/LongOrfs.err"
    shell: "cd out/all-merge ; \
        {TD}/TransDecoder.LongOrfs \
        -t {wildcards.model}.transcripts.fasta \
        -p 0 2> {log}"


rule makeblastdb:
    input: UNIPROT
    output: [UNIPROT+'.pin', UNIPROT+'.phr', UNIPROT+'.psq']
    benchmark: "out/benchmarks/makeblastdb.json"
    log: "out/logs/makeblastdb.txt"
    params: n="1", R="'span[hosts=1] rusage[mem=4]'", J="makeblastdb", o="out/logs/makeblastdb.out", eo="out/logs/makeblastdb.err"
    shell: "{BLAST}/makeblastdb \
        -in {UNIPROT} \
        -dbtype prot 2> {log}"


rule blastp:
    input: pep="out/all-merge/{model}.transcripts.fasta.transdecoder_dir/longest_orfs.pep",
        blastdb=[UNIPROT+'.pin', UNIPROT+'.phr', UNIPROT+'.psq']
    output: "out/all-merge/{model}.blastp.outfmt6"
    benchmark: "out/benchmarks/{model}.blastp.json"
    log: "out/logs/blastp.txt"
    params: n="24", R="'span[hosts=1] rusage[mem=4]'", J="blastp", o="out/logs/blastp.out", eo="out/logs/blastp.err"
    shell: "{BLAST}/blastp \
        -num_threads {params.n} \
        -query {input.pep}  \
        -db {UNIPROT}  \
        -max_target_seqs 1 \
        -outfmt 6 \
        -evalue 1e-5 \
        > {output} 2> {log}"


rule Predict:
    input: orfs="out/all-merge/{model}.transcripts.fasta.transdecoder_dir/longest_orfs.pep",
        fasta="out/all-merge/{model}.transcripts.fasta",
        blastp="out/all-merge/{model}.blastp.outfmt6"
    output: "out/all-merge/{model}.transcripts.fasta.transdecoder.pep",
        gff3="out/all-merge/{model}.transcripts.fasta.transdecoder.gff3"
    benchmark: "out/benchmarks/{model}.Predict.json"
    log: "../logs/Predict.txt"
    params: n="12", R="'span[hosts=1] rusage[mem=18]'", J="Predict", o="out/logs/Predict.out", eo="out/logs/Predict.err"
    shell: "cd out/all-merge; {TD}/TransDecoder.Predict \
        -t {wildcards.model}.transcripts.fasta \
        --single_best_orf \
        --cpu {params.n} \
        --retain_blastp_hits {wildcards.model}.blastp.outfmt6 2> {log}"


rule gtf_to_alignment_gff3:
    input: "out/all-merge/{model}.transcripts.gtf"
    output: "out/all-merge/{model}/transcripts.gff3"
    benchmark: "out/benchmarks/{model}.gtf_to_alignment_gff3.txt"
    log: "out/logs/gtf_to_alignment_gff3.txt"
    params: n="1", R="'span[hosts=1] rusage[mem=10]'", J="gtf_to_alignment_gff3", o="out/logs/gtf_to_alignment_gff3.out", eo="out/logs/gtf_to_alignment_gff3.err"
    shell: "{PROJECT}/util/cufflinks_gtf_to_alignment_gff3.pl {input} > {output} 2> {log}"


rule cdna_alignment_orf_to_genome_orf:
    input: gff3="out/all-merge/{model}/transcripts.gff3",
        fasta_td="out/all-merge/{model}.transcripts.fasta",
        gff3_td="out/all-merge/{model}.transcripts.fasta.transdecoder.gff3"
    output: "out/all-merge/{model}/transcripts.genome.gff3"
    benchmark: "out/benchmarks/{model}.cdna_alignment_orf_to_genome_orf.txt"
    log: "out/logs/cdna_alignment_orf_to_genome_orf.txt"
    params: n="1", R="'span[hosts=1] rusage[mem=10]'", J="cdna_alignment_orf_to_genome_orf", o="out/logs/cdna_alignment_orf_to_genome_orf.out", eo="out/logs/cdna_alignment_orf_to_genome_orf.err"
    shell: "{PROJECT}/util/cdna_alignment_orf_to_genome_orf.pl {input.gff3_td} {input.gff3} {input.fasta_td} > {output} 2> {log}"


rule gff3_file_to_bed:
    input: "out/all-merge/{model}/transcripts.genome.gff3"
    output: "out/all-merge/{model}/proteome.bed"
    benchmark: "out/benchmarks/{model}.gff3_file_to_bed.txt"
    log: "out/logs/gff3_file_to_bed.txt"
    params: n="1", R="'span[hosts=1] rusage[mem=10]'", J="gff3_file_to_bed", o="out/logs/gff3_file_to_bed.out", eo="out/logs/gff3_file_to_bed.err"
    shell: "cat {input} | grep -P \"\tCDS\t\" | {GFFREAD}/gffread --force-exons - -o- | {PROJECT}/util/gff3_file_to_bed.pl /dev/stdin | tail -n +2 > {output} 2> {log}"


rule gff3_file_to_proteins:
    input: "out/all-merge/{model}/transcripts.genome.gff3"
    output: "out/all-merge/{model}/proteome.fasta"
    benchmark: "out/benchmarks/{model}.gff3_file_to_proteins.txt"
    log: "out/logs/gff3_file_to_proteins.txt"
    params: n="1", R="'span[hosts=1] rusage[mem=10]'", J="gff3_file_to_proteins", o="out/logs/gff3_file_to_proteins.out", eo="out/logs/gff3_file_to_proteins.err"
    shell: "cat {input} | grep -P \"\tCDS\t\" | {GFFREAD}/gffread --force-exons - -o- | {PROJECT}/util/gff3_file_to_proteins_jtp.pl /dev/stdin {FASTA} | egrep -o '^[^*]+' > {output} 2> {log}"


rule reorderFASTA:
    input: "out/all-merge/{model}/proteome.fasta"
    output: "out/all-merge/{model}/proteome.unique.fasta"
    benchmark: "out/benchmarks/{model}.reorderFASTA.txt"
    log: "out/logs/reorderFASTA.txt"
    params: n="1", R="'span[hosts=1] rusage[mem=2]'", J="reorderFASTA", o="out/logs/reorderFASTA.out", eo="out/logs/reorderFASTA.err", wd=WD
    script: "reorderFASTA.R"