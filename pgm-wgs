WD="/data/kentsis/testing_scratchpad/test_fq"
workdir: WD
BWA='bwa'
BWA_VERSION='0.7.15-r1140'
SAMBLASTER='samblaster'
SAMTOOLS='samtools'
JAVA='java'
PICARD='picard'
PICARDJAR='~/picard.jar'
TMP='/scratch/kwokn/'
GATK37JAR='~/miniconda2/envs/wgs/opt/gatk-3.7/GenomeAnalysisTK.jar'
GATK4JAR='~/miniconda2/envs/wgs/share/gatk4-4.0b2-0/gatk-package-4.beta.2-local.jar'
SAMBAMBA='~/sambamba_v0.6.6'
BEDTOOLS='bedtools'

snakemake.utils.makedirs({WD})
snakemake.utils.makedirs('out/benchmarks')
snakemake.utils.makedirs('out/all-merge')
snakemake.utils.makedirs('out/logs')

SAMPLES=list(config['samples'].keys())
#BAMSAMPLES=list(config['bam_samples'].keys())
BAMSAMPLE='K052'
BAMSAMPLE_INPUT='/data/kentsis/WGS/K052_HemePACT/readgroups/s_OA_amlcl_003_CL_bc03_Proj_5932_L000.bam'
#BAMSAMPLE_INPUT='/data/kentsis/WGS/K052_HemePACT/s_OA_amlcl_003_CL_bc03_Proj_5932_L000_mrg_cl_aln_srt_MD_IR_BR.bam'
FASTQSAMPLE='RPE-GFP-PGBD5'
UNITS=list(config['units'].keys())
ALIGNMENTS=['aligned','realigned.alignments_merged']
NUM_TARGETS_RANGE=list(range(1,len(open(config['targets'],'r').readlines())+1))
NUM_VARIANT_INTERVALS=50 #Broad standard for GRCh38

rule all:
    input: expand("out/recal/K052.realigned_ubam_merged.RGmerged.dedup.fixedtags.{group}_recal.bam", group=NUM_TARGETS_RANGE), \
	   expand("out/intervals/{interval}-scattered.intervals", interval=[str(x).zfill(4) for x in range(NUM_VARIANT_INTERVALS)]), \
	   #expand("out/intervals/K052.realigned_ubam_merged.RGmerged.dedup.fixedtags.recal.{interval}.vcf.gz", interval=[str(x).zfill(4) for x in range(NUM_VARIANT_INTERVALS)])
	   #"out/RPE-GFP-PGBD5.aligned_fromfq.RGmerged.dedup.recal.finished.vcf"

rule AlignFastqReadsByRG:
    input: lambda wildcards: config["units"][wildcards.unit]
    output: temp("out/{unit}.aligned_fromfq.bam")
    benchmark: "out/benchmarks/{unit}.align.txt"
    params: n="36", R="'span[hosts=1] rusage[mem=10]'", o="out/logs/bwa_fastq.out", eo="out/logs/bwa_fastq.err", read_group=lambda wildcards: config["read_groups"][wildcards.unit], J="bwa_align_{wildcards.unit}"
    shell: "source activate wgs; {BWA} mem -M \
              -t {params.n} \
              -R '{params.read_group}' \
              {config[ref]} \
              {input} | \
            {SAMTOOLS} view -Shu -@ {params.n} - | \
            {SAMBAMBA} sort -n -m 350G --tmpdir {TMP} -t {params.n} -o {output}"

rule MergeFqRGsAndMarkDuplicates:
    input: temp(lambda wildcards: expand("out/{sample}.aligned_fromfq.bam", sample=config["samples"][wildcards.sample]))
    output: bam=temp("out/{sample}.aligned_fromfq.RGmerged.dedup.bam")
    params: n="36", R="'span[hosts=1] rusage[mem=11]'", o="out/logs/mergeRGs_markdups.out", eo="out/logs/mergeRGs_markdups.err", J="mergeRGs_markdups"
    shell: "source activate wgs; \
            {PICARD} MarkDuplicates -Xmx390g TMP_DIR={TMP} \
              $(echo '{input}' | sed -r \'s/[^ ]+/INPUT=&/g') \
              OUTPUT={output.bam} \
              METRICS_FILE=out/logs/markdups.metrics \
              VALIDATION_STRINGENCY=SILENT \
              OPTICAL_DUPLICATE_PIXEL_DISTANCE=2500 \
              ASSUME_SORT_ORDER='queryname' \
              MAX_RECORDS_IN_RAM=94000000"

rule CoordSortAndIndexForBQSR:
    input: bam=temp("out/{sample}.aligned_fromfq.RGmerged.dedup.bam")
    output: bam=temp("out/{sample}.aligned_fromfq.RGmerged.dedup.sorted.readyforBQSR.bam"),bai="out/{sample}.aligned_fromfq.RGmerged.dedup.sorted.readyforBQSR.bam.bai"
    params: n="36", R="'span[hosts=1] rusage[mem=10]'", o="out/logs/coordSort.out", eo="out/logs/coordSort.err", J="coordSort"
    shell: "{SAMBAMBA} sort -m 350G --tmpdir {TMP} -t {params.n} -o {output.bam} {input.bam} ; \
            {SAMBAMBA} index -t {params.n} {output.bam}"

snakemake.utils.makedirs('out/readgroups')

rule RevertUnmappedBAM:
    input: {BAMSAMPLE_INPUT}
    #output: expand("out/readgroups/{readgroup}.bam",readgroup=config["read_groups"])
    output: "out/readgroups/{readgroup}.reverted.bam"
    params: n="48", R="'span[hosts=1] rusage[mem=8]'", o="out/logs/revert_bam.out", eo="out/logs/revert_bam.err", J="revert_bam"
    shell: "{PICARD} RevertSam -Xmx256g I={input} O={output} TMP_DIR={TMP} MAX_RECORDS_IN_RAM=60000000"

rule RecreateFastqFromUBAM:
    input: "out/readgroups/{readgroup}.reverted.bam"
    output: fq1=temp("out/readgroups/{readgroup}.end1.fq"),fq2=temp("out/readgroups/{readgroup}.end2.fq")
    params: n="36", R="'span[hosts=1] rusage[mem=10]'", o="out/logs/recreate_fq.out", eo="out/logs/recreate_fq.err", J="recreate_fq"
    shell: "source activate wgs; \
              {SAMTOOLS} sort -n -T {TMP} -@ {params.n} -m 9G {BAMSAMPLE_INPUT} | \
              {BEDTOOLS} bamtofastq -i - -fq {output.fq1} -fq2 {output.fq2}"

rule RealignUnmappedBAM:
    input: fq1=temp("out/readgroups/{readgroup}.end1.fq"),fq2=temp("out/readgroups/{readgroup}.end2.fq")
    output: "out/readgroups/{readgroup}.realigned_unmerged.bam"
    params: n="64", R="'span[hosts=1] rusage[mem=4]'", o="out/logs/bwa_ubam.out", eo="out/logs/bwa_ubam.err", J="bwa_ubam"
    shell: "source activate wgs; \
            {BWA} mem -M -t {params.n} {config[ref]} {input.fq1} {input.fq2} | \
            {SAMTOOLS} view -uSh -@ {params.n} - | \
            {SAMBAMBA} sort -n --tmpdir {TMP} -m 250G -t {params.n} -o {output} /dev/stdin"

rule PicardSortUbamForMerging:
    #input: "out/readgroups/{readgroup}.bam"
    input: {BAMSAMPLE_INPUT}
    output: unmapped_namesorted=temp("out/readgroups/{readgroup}.unmapped_namesorted.bam")
    params: n="36", R="'span[hosts=1] rusage[mem=11]'", o="out/logs/reSort_ubam.out", eo="out/logs/reSort_ubam.err", J="reSort_ubam"
    shell: "{PICARD} SortSam -Xmx390g I={BAMSAMPLE_INPUT} O={output.unmapped_namesorted} \
              SORT_ORDER=queryname MAX_RECORDS_IN_RAM=93000000 TMP_DIR={TMP}"

rule MergeUnmappedAndRealignedBAMs:
    input: realigned="out/readgroups/{readgroup}.realigned_unmerged.bam", unmapped="out/readgroups/{readgroup}.unmapped_namesorted.bam"
    output: "out/readgroups/{readgroup}.realigned_ubam_merged.bam"
    params: n="36", R="'span[hosts=1] rusage[mem=10]'", o="out/logs/merge_realigned.out", eo="out/logs/merge_realigned.err", J="merge_realigned"
    shell: "source activate wgs; {PICARD} MergeBamAlignment -Xmx350g \
              TMP_DIR={TMP} \
              VALIDATION_STRINGENCY=SILENT \
              EXPECTED_ORIENTATIONS=FR \
              ATTRIBUTES_TO_RETAIN=X0 \
              ALIGNED_BAM={input.realigned} \
              UNMAPPED_BAM={input.unmapped} \
              OUTPUT={output} \
              REFERENCE_SEQUENCE={config[ref]} \
              PAIRED_RUN=true \
              SORT_ORDER='unsorted' \
              IS_BISULFITE_SEQUENCE=false \
              ALIGNED_READS_ONLY=false \
              CLIP_ADAPTERS=false \
              MAX_RECORDS_IN_RAM=85000000 \
              ADD_MATE_CIGAR=true \
              MAX_INSERTIONS_OR_DELETIONS=-1 \
              PRIMARY_ALIGNMENT_STRATEGY=MostDistant \
              PROGRAM_RECORD_ID='bwamem' \
              PROGRAM_GROUP_VERSION={BWA_VERSION} \
              PROGRAM_GROUP_COMMAND_LINE={BWA} \
              PROGRAM_GROUP_NAME='bwamem' \
              UNMAP_CONTAMINANT_READS=true"

rule MergeRealignedBamRGsAndMarkDuplicates:
    input: lambda wildcards: expand("out/readgroups/{sample}.realigned_ubam_merged.bam", sample=config["samples"][wildcards.sample])
    output: "out/{sample}.realigned_ubam_merged.RGmerged.dedup.bam"
    params: n="1", R="'span[hosts=1] rusage[mem=130]'", o="out/logs/markdups.out", eo="out/logs/markdups.err", J="markdups"
    shell: "source activate wgs; \
            {PICARD} MarkDuplicates -Xmx128g TMP_DIR={TMP} \
              $(echo '{input}' | sed -r \'s/[^ ]+/INPUT=&/g') \
	      OUTPUT={output} \
              METRICS_FILE='{WD}/out/logs/markdups.metrics' \
              VALIDATION_STRINGENCY=SILENT \
              OPTICAL_DUPLICATE_PIXEL_DISTANCE=2500 \
              ASSUME_SORT_ORDER='queryname' \
	      MAX_RECORDS_IN_RAM=32000000 \
              CREATE_MD5_FILE=true" 
    
rule SortAndFixRealignedBamTags:
    #input: expand("out/{sample}.{alignment}.dedup.bam", zip, sample=SAMPLES, alignment=['aligned.RGmerged','realigned.merged'])
    #output: "out/{sample}.{alignment}.dedup.fixedtags.bam"
    input: "out/{sample}.realigned_ubam_merged.RGmerged.dedup.bam"
    output: bam="out/{sample}.realigned_ubam_merged.RGmerged.dedup.fixedtags.readyforBQSR.bam", \
            idx="out/{sample}.realigned_ubam_merged.RGmerged.dedup.fixedtags.readyforBQSR.bai"
    benchmark: "out/benchmarks/SortAndFixTags.txt"
    params: n="36", R="'span[hosts=1] rusage[mem=10]'", \
            o="out/logs/sort_fix_tags.out", eo="out/logs/sort_fix_tags.err", \
            J="sort_fix_tags"
    shell: "{SAMBAMBA} sort -t {params.n} -m 350G --tmpdir {TMP} -o /dev/stdout {input} | \
            {PICARD} SetNmMdAndUqTags -Xmx64g TMP_DIR={TMP} \
              INPUT=/dev/stdin \
              OUTPUT={output.bam} \
              CREATE_INDEX=true \
              CREATE_MD5_FILE=true \
	      MAX_RECORDS_IN_RAM=16000000 \
              REFERENCE_SEQUENCE={config[ref]}"

rule CreateSequenceGroupings:
    input: config['dict']
    output: path="out/sequence_groups.txt"
    params: n="1", R="'span[hosts=1] rusage[mem=10]'", \
            o="out/logs/create_sequence_groups.out", eo="out/logs/create_sequence_groups.err", \
            J="create_seq_groups"
    run:
            with open(config['dict'],'r') as ref_dict_file:
                    sequence_tuple_list = []
                    longest_sequence = 0
                    for line in ref_dict_file:
                            if line.startswith("@SQ"):
                                    line_split = line.split("\t")
                                    # (Sequence_name, Sequence_length)
                                    sequence_tuple_list.append((line_split[1].split("SN:")[1], int(line_split[2].split("LN:")[1])))
                    longest_sequence = sorted(sequence_tuple_list, key=lambda x: x[1], reverse=True)[0][1]
            # initialize the txt string with the first sequence
            txt_string = sequence_tuple_list[0][0]
            temp_size = sequence_tuple_list[0][1]
            for sequence_tuple in sequence_tuple_list[1:]:
                    if temp_size + sequence_tuple[1] <= longest_sequence:
                            temp_size += sequence_tuple[1]
                            txt_string += "," + str(sequence_tuple[0])
                    else:
                            txt_string += " " + str(sequence_tuple[0])
                            temp_size = sequence_tuple[1]
            f = open(output.path,'w')
            f.write(txt_string)
            f.close()

snakemake.utils.makedirs('out/recal')
snakemake.utils.makedirs('out/logs/recal')

rule BaseRecalibrator:
    input: bam=temp("out/{sample_alignment}.readyforBQSR.bam"),groups_file=config['targets']#,bai="out/{sample_alignment}.readyforBQSR.bai"
    output: "out/recal/{sample_alignment}.{group}.report"
    params: n="8", R="'span[hosts=1] rusage[mem=4]'", \
	    o="out/logs/recal/{group}_recal.out", eo="out/logs/recal/{group}_recal.err", \
	    J="base_recal_{group}"
    wildcard_constraints: group="\d+"
    shell: "source activate wgs; {JAVA} -Dsamjdk.use_async_io=false \
              -Djava.io.tmpdir={TMP} -Xmx30g -jar {GATK37JAR} -T BaseRecalibrator \
              -nct 8 -R {config[ref]} -I {input.bam} \
	      --useOriginalQualities -o {output} \
              -knownSites {config[snp]} -knownSites {config[indel]} \
	      --interval_padding 100 \
	      -L $(sed -n {wildcards.group}p {input.groups_file} | sed -r 's/\t/ -L /g')"

rule GatherBqsrReports:
    input: expand("out/recal/{{sample_alignment}}.{group}.report", group=NUM_TARGETS_RANGE)
    output: "out/recal/{sample_alignment}.BQSR_full.report"
    params: n="8", R="'span[hosts=1] rusage[mem=10]'", \
	    o="out/logs/gather_reports.out", eo="out/logs/gather_reports.err", \
	    J="gather_reports"
    shell: "source activate wgs; {JAVA} -Xmx32g -cp {GATK37JAR} org.broadinstitute.gatk.tools.GatherBqsrReports \
	      $(echo {input} | sed -r 's/[^ ]+/INPUT=&/g') \
	      OUTPUT={output}"

rule ApplyBQSRToMappedReads:
    input: bqsr="out/recal/{sample_alignment}.BQSR_full.report",bam=temp("out/{sample_alignment}.readyforBQSR.bam"), \
	   groups_file=config['targets']
    output: temp("out/recal/{sample_alignment}.{group}_recal.bam")
    wildcard_constraints: group="\d+"
    params: n="8", R="'span[hosts=1] rusage[mem=4]'", \
	    o="out/logs/mapped_bqsr_{group}.out", eo="out/logs/mapped_bqsr{group}.err", \
	    J="mapped_bqsr"
    shell: "source activate wgs; {JAVA} -XX:+PrintFlagsFinal -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps \
	      -XX:+PrintGCDetails -Xloggc:gc_log.log -Dsamjdk.use_async_io=false \
	      -XX:GCTimeLimit=50 -XX:GCHeapFreeLimit=10 -Xmx30g \
	      -jar {GATK37JAR} -T PrintReads -nct 8 --generate_md5 --keep_program_records \
	      -R {config[ref]} -I {input.bam} --useOriginalQualities -o {output} \
	      --BQSR {input.bqsr} -SQQ 10 -SQQ 20 -SQQ 30 -SQQ 40 --emit_original_quals \
	      -L $(sed -n {wildcards.group}p {input.groups_file} | sed -r 's/\t/ -L /g')"

rule ApplyBQSRToUnmappedReads:
    input: bqsr="out/recal/{sample_alignment}.BQSR_full.report",bam=temp("out/{sample_alignment}.readyforBQSR.bam"), \
	   groups_file=config['targets']
    output: temp("out/recal/{sample_alignment}.unmapped_recal.bam")
    params: n="8", R="'span[hosts=1] rusage[mem=4]'", \
	    o="out/logs/unmapped_bqsr.out", eo="out/logs/unmapped_bqsr.err", \
	    J="unmapped_bqsr"
    shell: "source activate wgs; {JAVA} -XX:+PrintFlagsFinal -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps \
	      -XX:+PrintGCDetails -Xloggc:gc_log.log -Dsamjdk.use_async_io=false \
	      -XX:GCTimeLimit=50 -XX:GCHeapFreeLimit=10 -Xmx32g \
	      -jar {GATK37JAR} -T PrintReads -nct 8 --generate_md5 --keep_program_records \
	      -R {config[ref]} -I {input.bam} --useOriginalQualities -o {output} \
	      --BQSR {input.bqsr} -SQQ 10 -SQQ 20 -SQQ 30 -SQQ 40 --emit_original_quals \
	      -L unmapped"
	     
rule GatherRecalibratedBAMs:
    input: mapped=expand(temp("out/recal/{{sample_alignment}}.{group}_recal.bam"),group=NUM_TARGETS_RANGE), \
	   unmapped=temp("out/recal/{sample_alignment}.unmapped_recal.bam")
    output: "out/{sample_alignment}.recal.bam"
    params: n="4", R="'span[hosts=1] rusage[mem=9]'", \
	    o="out/logs/gather_recal.out", eo="out/logs/gather_recal.err", \
	    J="gather_recal"
    shell: "source activate wgs; {PICARD} GatherBamFiles -Xmx32g \
              $(echo '{input.mapped}' | sed -r \'s/[^ ]+/INPUT=&/g') \
	      INPUT={input.unmapped} OUTPUT={output} \
	      CREATE_INDEX=true CREATE_MD5_FILE=true"


snakemake.utils.makedirs('out/intervals')
snakemake.utils.makedirs('out/logs/intervals')

rule ScatterIntervals:
    input: config['wgs_calling_regions']
    output: "out/intervals/{interval}-scattered.intervals"
    params: n="2", R="'span[hosts=1] rusage[mem=9]'", \
	    o="out/logs/intervals/{interval}.out", eo="out/logs/intervals/{interval}.err", \
	    J="generate_intervals_{interval}"
    shell: "source activate wgs; {JAVA} -Xmx16g -jar {GATK4JAR} SplitIntervals \
	      -R {config[ref]} -L {input} -scatter {NUM_VARIANT_INTERVALS} \
	      -O {WD}/out/intervals"

rule CreateScatteredGVCFs:
    input: bam="out/{sample_alignment}.recal.bam", interval_list="out/intervals/{interval}-scattered.intervals"
    output: temp("out/intervals/{sample_alignment}.recal.{interval}.vcf.gz")
    params: n="1", R="'span[hosts=1] rusage[mem=18]'", \
	    o="out/logs/intervals/vcf_{interval}.out", eo="out/logs/intervals/vcf_{interval}.err", \
	    J="generate_vcf_{interval}"
    shell: "source activate wgs; {JAVA} -XX:GCTimeLimit=50 -XX:GCHeapFreeLimit=10 -Xmx16g \
	      -jar {GATK37JAR} -T HaplotypeCaller -R {config[ref]} \
	      -o {output} -I {input.bam} -L {input.interval_list} \
	      -ERC GVCF --max_alternate_alleles 3 \
	      -variant_index_parameter 128000 -variant_index_type LINEAR \
	      -contamination 0 --read_filter OverclippedRead"

rule GatherScatteredGVCFs:
    input: expand(temp("out/intervals/{{sample_alignment}}.recal.{interval}.vcf.gz"),interval=[str(x).zfill(4) for x in range(NUM_VARIANT_INTERVALS)])
    output: "out/{sample_alignment}.recal.finished.vcf"
    params: n="32", R="'span[hosts=1] rusage[mem=4]'", \
	    o="out/logs/merge_gvcfs.out", eo="out/logs/merge_gvcfs.err", \
	    J="merge_gvcfs"
    shell: "source activate wgs; {JAVA} -Xmx64g -jar {GATK37JAR} -nt 32 -T GenotypeGVCFs -R {config[ref]} \
	      $(echo '{input}' | sed -r 's/[^ ]+/--variant &/g') \
              -o {output}"
    #shell: "{PICARD} MergeVcfs \
    #          $(echo '{input}' | sed -r 's/[^ ]+/INPUT=&/g') \
    #          OUTPUT={output}"
    
