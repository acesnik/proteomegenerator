# variables
PY = '/home/kwokn/miniconda2/bin/python'
#PICARD = '/ifs/e63data/poirierj/bin/picard-tools-1.134/picard.jar'
#BEDTOOLS = '/ifs/opt/common/CentOS_6/bedtools/bedtools-2.22.0/bin/bedtools'
#BEDOPS = '/ifs/e63data/poirierj/bin/bedops/bin'
#STRINGTIE='/ifs/e63data/poirierj/bin/stringtie-1.3.3b.Linux_x86_64/stringtie'
GTF='/home/kwokn/proteomegenerator/indexes/GRCh38/gencode.v20.annotation.gtf'
FASTA='/home/kwokn/proteomegenerator/indexes/GRCh38.genome.fa'
#TD="/ifs/e63data/poirierj/bin/TransDecoder"
#GFFREAD="/ifs/e63data/poirierj/bin/gffread/gffread-0.9.8.Linux_x86_64"
#GFFCOMPARE="/ifs/e63data/poirierj/bin/gffcompare/gffcompare-0.9.8.Linux_x86_64/gffcompare"
#BLAST="/ifs/e63data/poirierj/bin/ncbi-blast-2.2.31+/bin"
#HMMSCAN="/ifs/e63data/poirierj/bin/hmmer-3.1b2-linux-intel-x86_64/binaries/hmmscan"
UNIPROT="/home/kwokn/proteomegenerator/indexes/uniprot/UP000005640.fasta"
#PFAM="/ifs/e63data/poirierj/indexes/pfam/Pfam-A.hmm"
#FEATURECOUNTS="/ifs/e63data/poirierj/bin/subread-1.5.0-p2-Linux-x86_64/bin/featureCounts"
PGX="/home/kwokn/PGx"
RSCRIPT='/opt/common/CentOS_7/R/R-3.3.3/bin/Rscript'
SCRIPTS='/home/kwokn/scripts'
TMP = '/scratch/kwokn'
EMBOSS = "~/miniconda2/pkgs/emboss-6.5.7-2/bin"

#SAMPLES, = glob_wildcards("out/{sample}.Aligned.sortedByCoord.out.bam")
SAMPLES = "FCH9EFLADXX-HUMbghEAACRAAPEI-225".split()
OUTLOG = "logs"

MODELS = 'merged reference'.split()
ADBS = expand('adb{n}',n=range(1,8))
DBS = ADBS + 'merged reference uniprot Ecoli loki'.split()

snakemake.utils.makedirs('/scratch/kwokn')
snakemake.utils.makedirs('out/benchmarks')
snakemake.utils.makedirs('out/all-merge')
snakemake.utils.makedirs('logs/cluster')

rule all:
    input: 
        #expand("out/all-merge/{db}.db.fasta.pepdigest",db=DBS),
        expand("out/all-merge/{model}/proteome.bed",model=MODELS),
        expand("out/all-merge/{model}/proteome.fasta",model=MODELS),
	expand("out/{sample}.Aligned.sortedByCoord.out.bam",sample=SAMPLES)

rule BuildBamIndex:
    input: "out/{sample}.Aligned.sortedByCoord.out.bam"
    output: "out/{sample}.Aligned.sortedByCoord.out.bai"
    benchmark: "out/benchmarks/{sample}.BuildBamIndex.txt"
    params: n="1", R="'span[hosts=1] rusage[mem=10]'", \
            o="logs/out.buildbamindex", eo="logs/error.buildbamindex", \
            J="BuildBamIndex"
    shell: "picard BuildBamIndex -Xmx6g TMP_DIR={TMP} I={input}"

rule StringTie:
    input: bam="out/{sample}.Aligned.sortedByCoord.out.bam", bai="out/{sample}.Aligned.sortedByCoord.out.bai"
    output: "out/{sample}-stringtie.gtf"
    benchmark: "out/benchmarks/{sample}.StringTie.txt"
    params: n="16", R="'span[hosts=1] rusage[mem=8]'", \
            o="logs/out.stringtie", eo="logs/error.stringtie", \
	    J="StringTie"
    shell: "stringtie \
            -G {GTF} \
            {input.bam} \
            -p {params.n} \
            -o {output}"

snakemake.utils.makedirs('out/all-merge')

# rule merge_model:
#     input: "out/{sample}-stringtie.gtf"
#     output: "out/{sample}-stringtie.clean.gtf"
#     benchmark: "out/benchmarks/gtf_file_to_cDNA_seqs.txt"
#     params: pe="1", mem="h_vmem=10G,virtual_free=8G", err="~/error/error.gtf_file_to_cDNA_seqs", name="gtf_file_to_cDNA_seqs"
#     shell: "{GFFREAD}/gffread {input} -T -o {output} \
#         --no-pseudo \
#         --force-exons \
#         -M -Q"


rule merge:
    #input: "out/{sample}-stringtie.gtf"
    input: expand("out/{sample}-stringtie.gtf",sample=SAMPLES)
    output: "out/all-merge/merged.gtf"
    benchmark: "out/benchmarks/merge.txt"
    params: n="12", R="'span[ptile=72] rusage[mem=4]'", \
            o="logs/out.merge", eo="logs/error.merge", \
            J="merge"
    shell: "stringtie \
            --merge \
            -o {output} \
            -p {params.n} \
            -c 2.5 \
            -T 1 \
            -f .1 \
            -i \
            {input}"        
    #params: pe="12", mem="h_vmem=4G,virtual_free=3G", err="~/error/error.merge", name="merge"
    #shell: "{STRINGTIE} \
    #        --merge \
    #        -o {output} \
    #        -p {params.pe} \
    #        -c 0 \
    #        -T 1 \
    #        -f .1 \
    #        -i \
    #        {input}"


# rule gffcompare:
#     input: "out/all-merge/merged.gtf"
#     output: gtf="out/all-merge/gffcmp.annotated.gtf", stats="out/all-merge/gffcmp.stats"
#     benchmark: "out/benchmarks/gffcompare.txt"
#     params: pe="1", mem="h_vmem=8G,virtual_free=7G", err="~/error/error.gffcompare", name="gffcompare"
#     shell: "{GFFCOMPARE} \
#             -G \
#             -r {GTF} \
#             -R \
#             -s {FASTA} \
#             -o out/all-merge/gffcmp \
#             {input}"


rule UCSC:
    input: "out/all-merge/merged.gtf"
    output: merged="out/all-merge/merged-UCSC.gtf", reference="out/all-merge/reference-UCSC.gtf"
    benchmark: "out/benchmarks/UCSC.txt"
    params: n="1", R="'span[ptile=72] rusage[mem=10]'", \
            o="logs/UCSC.out", eo="logs/UCSC.err", \
            J="UCSC"
    shell: "cat {GTF} | grep chr > {output.reference}; \
        cat {input} | grep chr > {output.merged}"
    #params: pe="1", mem="h_vmem=10G,virtual_free=8G", err="~/error/error.snake", name="UCSC"
    #shell: "cat {GTF} | grep chr > {output.reference}; \
    #    cat {input} | grep chr > {output.merged}"

rule gtf_file_to_cDNA_seqs:
    input: "out/all-merge/{model}-UCSC.gtf"
    output: fasta="out/all-merge/{model}.transcripts.fasta",
            gtf="out/all-merge/{model}.transcripts.gtf"
    benchmark: "out/benchmarks/gtf_file_to_cDNA_seqs.txt"
    params: n="1", R="'span[hosts=1] rusage[mem=16]'", \
            o="logs/{model}.gtf_file_to_cDNA_seqs.out", eo="logs/{model}.gtf_file_to_cDNA_seqs.err", \
            J="gtf_file_to_cDNA_seqs"
    shell: "gffread {input} -T -o {output.gtf} \
        --no-pseudo \
        --force-exons \
        -M -Q; \
        gffread -w {output.fasta} -g {FASTA} {output.gtf}"
    #params: pe="1", mem="h_vmem=10G,virtual_free=8G", err="~/error/error.gtf_file_to_cDNA_seqs", name="gtf_file_to_cDNA_seqs"
    #shell: "{GFFREAD}/gffread {input} -T -o {output.gtf} \
    #    --no-pseudo \
    #    --force-exons \
    #    -M -Q; \
    #    {GFFREAD}/gffread -w {output.fasta} -g {FASTA} {output.gtf}"


# rule index_cdna_seqs:
#     input: "out/all-merge/{model}.transcripts.fasta"
#     output: "out/all-merge/{model}.transcripts.fasta.idx"
#     benchmark: "out/benchmarks/{model}.index_cdna_seqs.txt"
#     params: pe="1", mem="h_vmem=20G,virtual_free=18G", err="~/error/error.idx", name="idx"
#     shell: "{SF}/util/index_cdna_seqs.pl {input}"


rule LongOrfs:
    input: "out/all-merge/{model}.transcripts.fasta"#,"out/all-merge/{model}.transcripts.fasta.idx"
    output: "out/all-merge/{model}.transcripts.fasta.transdecoder_dir/longest_orfs.pep"
    benchmark: "out/benchmarks/{model}.LongOrfs.json"
    params: n="16", R="'span[ptile=16] rusage[mem=8]'", J="LongOrfs", \
	    o="logs/{model}.LongOrfs.out", eo="logs/{model}.LongOrfs.err"
    shell: "cd out/all-merge; \
            TransDecoder.LongOrfs \
	    -t {wildcards.model}.transcripts.fasta \
            -p 0"
    #params: pe="1", mem="h_vmem=10G,virtual_free=8G", err="~/error/error.LongOrfs", name="LongOrfs"
    #shell: "cd out/all-merge ; \
    #    {TD}/TransDecoder.LongOrfs \
    #    -t {wildcards.model}.transcripts.fasta \
    #    -p 0"

rule blastp:
    input: "out/all-merge/{model}.transcripts.fasta.transdecoder_dir/longest_orfs.pep"
    output: "out/all-merge/{model}.blastp.outfmt6"
    benchmark: "out/benchmarks/{model}.blastp.json"
    params: n="64", R="'span[hosts=1] rusage[mem=4]'", J="blastp", \
	    o="logs/{model}.blastp.out", eo="logs/{model}.blastp.err"
    shell: "blastp \
            -num_threads {params.n} \
            -query {input} \
            -db {UNIPROT} \
            -max_target_seqs 1 \
            -outfmt 6 \
            -evalue 1e-5 \
            > {output}"
    #params: pe="12", mem="h_vmem=4G,virtual_free=3G", err="~/error/error.blastp", name="blastp"
    #shell: "{BLAST}/blastp \
    #    -num_threads {params.pe} \
    #    -query {input}  \
    #    -db {UNIPROT}  \
    #    -max_target_seqs 1 \
    #    -outfmt 6 \
    #    -evalue 1e-5 \
    #    > {output}"

# rule pfam:
#     input: "out/all-merge/transcripts.fasta.transdecoder_dir/{model}.longest_orfs.pep"
#     output: "out/all-merge/{model}.pfam.domtblout"
#     benchmark: "out/benchmarks/{model}.pfam.json"
#     params: pe="12", mem="h_vmem=10G,virtual_free=8G", err="~/error/error.pfam", name="pfam"
#     shell: "{HMMSCAN} \
#         --cpu {params.pe} \
#         --domtblout {output} \
#         {PFAM} \
#         {input}"

rule Predict:
    input: orfs="out/all-merge/{model}.transcripts.fasta.transdecoder_dir/longest_orfs.pep",
        fasta="out/all-merge/{model}.transcripts.fasta",
        blastp="out/all-merge/{model}.blastp.outfmt6"
    output: "out/all-merge/{model}.transcripts.fasta.transdecoder.pep",
        gff3="out/all-merge/{model}.transcripts.fasta.transdecoder.gff3"
    benchmark: "out/benchmarks/{model}.Predict.json"
#    params: pe="1", mem="h_vmem=225G,virtual_free=200G", err="~/error/error.Predict", name="Predict"
    #params: pe="12", mem="h_vmem=18G,virtual_free=16G", err="~/error/error.Predict", name="Predict"
    params: n="64", R="'span[ptile=64] rusage[mem=4]'", J="Predict", \
	    o="logs/{model}.Predict.out", eo="logs/{model}.Predict.err"
    shell: "cd out/all-merge; TransDecoder.Predict \
        -t {wildcards.model}.transcripts.fasta \
        --single_best_orf \
        --cpu {params.n} \
       --retain_blastp_hits {wildcards.model}.blastp.outfmt6"


rule gtf_to_alignment_gff3:
    input: "out/all-merge/{model}.transcripts.gtf"
    output: "out/all-merge/{model}/transcripts.gff3"
    benchmark: "out/benchmarks/{model}.gtf_to_alignment_gff3.txt"
    params: n="8", R="'span[ptile=8] rusage[mem=16]'", J="gtf_to_alignment_gff3", \
	    o="logs/{model}.gtf_to_alignment_gff3.out", eo="logs/{model}.gtf_to_alignment_gff3.err"
    shell: "cufflinks_gtf_to_alignment_gff3.pl {input} > {output}"


rule cdna_alignment_orf_to_genome_orf:
    input: gff3="out/all-merge/{model}/transcripts.gff3",
        fasta_td="out/all-merge/{model}.transcripts.fasta",
        gff3_td="out/all-merge/{model}.transcripts.fasta.transdecoder.gff3"
    output: "out/all-merge/{model}/transcripts.genome.gff3"
    benchmark: "out/benchmarks/{model}.cdna_alignment_orf_to_genome_orf.txt"
    params: n="8", R="'span[ptile=8] rusage[mem=16]'", J="cdna_alignment_orf_to_genome_orf", \
	    o="logs/{model}.cdna_alignment_orf_to_genome_orf.out", eo="logs/{model}.cdna_alignment_orf_to_genome_orf.err"
    shell: "cdna_alignment_orf_to_genome_orf.pl {input.gff3_td} {input.gff3} {input.fasta_td} > {output}"


rule gff3_file_to_bed:
    input: "out/all-merge/{model}/transcripts.genome.gff3"
    output: "out/all-merge/{model}/proteome.bed"
    benchmark: "out/benchmarks/{model}.gff3_file_to_bed.txt"
    params: n="8", R="'span[ptile=8] rusage[mem=16]'", err="~/error/error.gff3_file_to_bed", J="gff3_file_to_bed", \
	    o="logs/{model}.gff3_file_to_bed.out", eo="logs/{model}.gff3_file_to_bed.err"
    shell: "cat {input} | grep -P \"\tCDS\t\" | gffread --force-exons - -o- | gff3_file_to_bed.pl /dev/stdin | tail -n +2 > {output}"#"| awk '{{ print $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12; OFS=\"\t\" }}' > {output}"
#&& [[ -s {output} ]]

# rule gff3_file_to_bed:
#     input: "out/all-merge/{model}/transcripts.genome.gff3"
#     output: "out/all-merge/{model}/proteome.bed"
#     benchmark: "out/benchmarks/{model}.gff3_file_to_bed.txt"
#     params: pe="1", mem="h_vmem=10G,virtual_free=8G", err="~/error/error.gff3_file_to_bed", name="gff3_file_to_bed"
#     shell: "awk '($3==\"CDS\") {{OFS=\"\t\"; print $1,$4-1,$5,\"\\t\\t\\t\\t\\t\\t\\t\\t\"}}' {input} > {output}"


rule gff3_file_to_proteins:
    input: "out/all-merge/{model}/transcripts.genome.gff3"
    output: "out/all-merge/{model}/proteome.fasta"
    benchmark: "out/benchmarks/{model}.gff3_file_to_proteins.txt"
    params: n="8", R="'span[ptile=8] rusage[mem=16]'", err="~/error/error.gff3_file_to_proteins", J="gff3_file_to_proteins", \
	    o="logs/{model}.gff3_file_to_proteins.out", eo="logs/{model}.gff3_file_to_proteins.err"
    shell: "cat {input} | grep -P \"\tCDS\t\" | gffread --force-exons - -o- | gff3_file_to_proteins_jtp.pl /dev/stdin {FASTA} | egrep -o '^[^*]+' > {output}"


# rule gff3_file_to_proteins:
#     input: "out/all-merge/{model}/transcripts.genome.gff3"
#     output: fasta="out/all-merge/{model}/proteome.fasta",
#         gff3="out/all-merge/{model}/proteome.gff3"
#     benchmark: "out/benchmarks/{model}.gff3_file_to_proteins.txt"
#     params: pe="1", mem="h_vmem=10G,virtual_free=8G", err="~/error/error.gff3_file_to_proteins", name="gff3_file_to_proteins"
#     shell: "cat {input} | grep -P \"\tCDS\t\" | {GFFREAD}/gffread - -g {FASTA} -y {output.fasta} -F --force-exons -o {output.gff3}"


# rule convert2bed:
#     input: "out/all-merge/{model}/proteome.gff3"
#     output: "out/all-merge/{model}/proteome.bed"
#     benchmark: "out/benchmarks/{model}.gff2bed.txt"
#     params: pe="1", mem="h_vmem=10G,virtual_free=8G", err="~/error/error.gff2bed", name="gff2bed"
#     shell: "{BEDOPS}/convert2bed -i gff < {input} > {output}"


# rule gff3_file_to_bed:
#     input: "out/all-merge/{model}/proteome.gff3"
#     output: "out/all-merge/{model}/proteome.bed"
#     benchmark: "out/benchmarks/{model}.gff3_file_to_bed.txt"
#     params: pe="1", mem="h_vmem=10G,virtual_free=8G", err="~/error/error.gff3_file_to_bed", name="gff3_file_to_bed"
#     shell: "{TD}/util/gff3_file_to_bed.pl {input} | tail -n +2 > {output}"#"| awk '{{ print $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12; OFS=\"\t\" }}' > {output}"


rule reorderFASTA:
    input: "out/all-merge/{model}/proteome.fasta"
    output: "out/all-merge/{model}/proteome.unique.fasta"
    benchmark: "out/benchmarks/{model}.reorderFASTA.txt"
    params: n="4", R="'span[hosts=1] rusage[mem=4]'", J="reorderFASTA", \
	    o="logs/{model}.reorderFASTA.out", eo="logs/{model}.reorderFASTA.err"
    shell: "{RSCRIPT} {SCRIPTS}/reorderFASTA.R {input} {output}"


# rule getfasta:
#     input: "out/all-merge/{model}/proteome.bed"
#     output: "out/all-merge/{model}/proteome.fasta"
#     benchmark: "out/benchmarks/{model}.getfasta.txt"
#     params: pe="1", mem="h_vmem=10G,virtual_free=8G", err="~/error/error.getfasta", name="getfasta"
#     shell: "{BEDTOOLS} getfasta -name -s -fi {FASTA} -bed {input} -fo /dev/stdout | {EMBOSS}/transeq -sequence /dev/stdin -outseq {output}"


# rule PGx_prepare:
#     input: "out/all-merge/{model}/transcripts.genome.gff3"
#     output: fasta="out/all-merge/{model}/proteome.fasta",
#         bed="out/all-merge/{model}/proteome.bed"
#     benchmark: "out/benchmarks/{model}.PGx_prepare.txt"
#     params: pe="1", mem="h_vmem=10G,virtual_free=8G", err="~/error/error.PGx_prepare", name="PGx_prepare"
#     shell: "{RSCRIPT} {SCRIPTS}/reorderFASTA.R {WD}/{input} {WD}/{output.fasta} {WD}/{output.bed}"


rule PGx_index:
    input: fasta="out/all-merge/{model}/proteome.fasta",
        bed="out/all-merge/{model}/proteome.bed"
    output: "out/all-merge/{model}/proteome.pickle"
    benchmark: "out/benchmarks/{model}.PGx_index.txt"
    params: n="4", mem="'span[hosts=1] rusage=[4]'", J="PGx_index", \
	    o="logs/{model}.PGx_index.out", eo="logs/{model}.PGx_index.err"
    shell: "{PY} {PGX}/pgx_index.py \
        out/all-merge/{wildcards.model}"


rule PGx_query:
    input: pep="out/all-merge/{model}/peptides.txt",
        index="out/all-merge/{model}/proteome.pickle"
    output: hits="out/all-merge/{model}/hits.txt"
    benchmark: "out/benchmarks/{model}.PGx_index.txt"
    params: n="4", mem="'span[hosts=1] rusage=[4]'", J="PGx_query", \
	    o="logs/{model}.PGx_query.out", eo="logs/{model}.PGx_query.err"
    shell: "{PY} {PGX}/pgx_query.py \
        out/all-merge/{wildcards.model} \
        {input.index} > {output}"


rule PGx_bed:
    input: hits="out/all-merge/{model}/hits.txt",
        index="out/all-merge/{model}/proteome.pickle"
    output: bed="out/all-merge/{model}/hits.bed"
    benchmark: "out/benchmarks/{model}.PGx_index.txt"
    params: n="4", mem="'span[hosts=1] rusage=[4]'", J="PGx_bed", \
	    o="logs/{model}.PGx_bed.out", eo="logs/{model}.PGx_bed.err"
    shell: "{PY} {PGX}/pgx_bed.py \
        out/all-merge/{wildcards.model} \
        {input.hits} \
        > {output}"

#rule pepdigest:
#    input: "out/all-merge/{db}.db.fasta"
#    output: "out/all-merge/{db}.db.fasta.pepdigest"
#    benchmark: "out/benchmarks/{db}.pepdigest.txt"
#    params: pe="1", mem="h_vmem=10G,virtual_free=8G", err="~/error/error.pepdigest", name="pepdigest"
#    shell: "{EMBOSS}/pepdigest \
#            -seqall {input} \
#            -menu 1 \
#            -outfile {output} \
#            -auto"

#rule MSFragger:
#    input: spectra='out/all-merge/{model}.mzXML',
#        peptide_db=''
#    output: 'out/all-merge/{model}.pepXML'
#    benchmark: 'benchmarks/{sample}.fragger'
#    shell: 'cd {MSFRAG_DIR}; \
#            java -Xmx32G -jar MSFragger.jar fragger.params {input}'
#
#snakemake --snakefile pgm-new --cluster "bsub -J {params.J} -n {params.n} -R {params.R} -W 3:00 -o ‘logs/{params.J}.stdout' -eo ‘logs/{params.J}.stderr'" -j 100 -k --ri --latency-wait 30 -np
#
